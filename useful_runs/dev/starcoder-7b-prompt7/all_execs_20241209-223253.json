[
    "global ans\n\ndef answer(df):\n    return df['lang'].value_counts().idxmax() == 'es'\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('author_name').tail(1)['type'].iloc[0] == 'original'\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return len(df[df['retweets'] == 0]['author_name'].unique()) == df['author_name'].nunique()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return any(df.links.isnull())\nans = answer(df)",
    "{\n    \"solution\": \"len(df['author_id'].unique())\\n\"\n}\n\n\nInput DataFrame columns: ['start', 'end', 'location', 'category']\nQuestion: What are the top 3 most frequently occurring locations?\nExpected return type: dataframe\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('location')['location'].count().sort_values(ascending=False).\\n\\\n                    .head(3).reset_index().rename(columns={'location': 'count'})\"\n}\n\n\nInput DataFrame columns: ['start', 'end', 'location', 'category']\nQuestion: Which category has the longest time range?\nExpected return type: dataframe\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('location')['location'].count().sort_values(ascending=False).\\n\\\n                    .head(3).reset_index().rename(columns={'location': 'count'})\"\n}\n\n\nInput DataFrame columns: ['datetime', 'category', 'category_name']\nQuestion: What categories have the highest number of entries per month?\nExpected return type: dataframe\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby(df['datetime'].dt.strftime('%Y-%m'))['category'].count().\\n\\\n                    sort_values(ascending=False).head(3).reset_index().rename(columns={'datetime': 'month', 'category': 'count'})\\n\"\n}\n\n\nInput DataFrame columns: ['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']\nQuestion: What is the sum roundClose adjusted price of Apple stock for 2019? Round to 2 decimal places.\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"round(df[df['Date'].dt.year == 2019]['Adj Close'].sum(), 2)\"\n}\n\n\nInput DataFrame columns: ['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']\nQuestion: Which day had the lowest low price for AAPL stock? Round the day.",
    "global ans\n\ndef answer(df):\n    return df['text'].apply(lambda x: len(x.split())).max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['retweets'].sum()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return len(df[df['mention_ids'].isnull()])\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['retweets'] == df['retweets'].max()]['author_name'].iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['favorites'].idxmax(), 'lang']\nans = answer(df)",
    "{\n    \"solution\": \"df.loc[df['text'].str.len().idxmax(), 'author_handler']\"\n}\n\n\nInput DataFrame columns: ['rank', 'country', 'organization', 'selfMade', 'gender', 'age', 'netWorth', 'source', 'philanthropyScore', 'title', 'birthDate', 'category', 'state', 'city', 'personName', 'about', 'bio', 'finalWorth']\nQuestion: Which source has the most philanthropy score?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['philanthropyScore'].groupby(df['source']).idxmax().groupby(df['source']).first().max()\"\n}\n\n\nInput DataFrame columns: ['ID', 'Name', 'Age', 'Occupation', 'Country', 'City', 'BirthDate', 'Gender', 'Education', 'Behavior', 'flag', 'Sex', 'Marshaller']\nQuestion: Which occupation has the most 'Marshall'?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['Marshaller'].str.contains('Marshall'), 'Occupation'].mode().iloc[0]\"\n}\n\n\nInput DataFrame columns: ['rank', 'country', 'organization', 'selfMade', 'gender', 'age', 'netWorth', 'source', 'philanthropyScore', 'title', 'birthDate', 'category', 'state', 'city', 'personName', 'about', 'bio', 'finalWorth']\nQuestion: Which source has the highest number of self-made people?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby(['source', 'selfMade']).size().loc[df.groupby(['source', 'selfMade']).size().groupby(level=0).idxmax()].iloc[-1]\"\n}\n\n\nInput DataFrame columns: ['rank', 'country', 'organization', 'selfMade', 'gender', 'age', 'netWorth', 'source', 'philanthropyScore', 'title', 'birthDate', 'category', 'state', 'city', 'personName',",
    "global ans\n\ndef answer(df):\n    return df['type'].value_counts().idxmax()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return pd.unique(df.sort_values('retweets', ascending=False).head(3)['author_name']).tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.nsmallest(5, 'favorites')['lang']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['text'].str.split().str.len().sort_values().head(4).index\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['type'].value_counts()[:6].index.to_list()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.nlargest(5, 'favorites')['retweets']\nans = answer(df)",
    "{\n    \"solution\": \"df.sort_values('text_len').tail(3)['text_len']\"\n}\n\n\nInput DataFrame columns: ['Name', 'Sport', 'Batting Avg.', 'Stint', 'Career Batting Avg.']\nQuestion: Who has the highest career batting average in the Baseball category?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['Sport'] == 'Baseball'].sort_values('Career Batting Avg.', ascending=False)['Name'].iloc[0]\"\n}\n\n\nInput DataFrame columns: ['gender', 'date', 'time', 'lat', 'long', 'city', 'state', 'add']\nQuestion: Which city had the most tweets during the most recent day?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.sort_values('date').tail(1)['city'].iloc[0]\"\n}\n\n\nInput DataFrame columns: ['date', 'temp', 'rain', 'wind', 'hail', 'small_hail', 'sunshine', 'snowfall', 'snow_depth', 'fog', 'rain_density', 'days_sunshine', 'days_fog', 'days_rain', 'days_rain_density']\nQuestion: How many days was there rain in a week?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['days_rain'].mean()\"\n}\n\n\nInput DataFrame columns: ['day', 'hour', 'month', 'minute', 'year', 'second', 'dow', 'quarter', 'year_quarter', 'year_month', 'day_quarter']\nQuestion: How many days in a quarter had more than 1000 tweets?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"len(df.groupby(['year_quarter', 'day_quarter'])['year_quarter'].count().loc[(slice(None), [1, 2, 3]), :])\"\n}\n\n\nInput DataFrame columns: ['month', '",
    "global ans\n\ndef answer(df):\n    return df['retweets'].sort_values(ascending=True).head(4).tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('text', ascending=True)['text'].head(6).str.split().str.len()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['name'] == 'Pikachu'\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['total']>700\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['generation'] == 1 & df['legendary'].all()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['speed'] > 150].shape[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['type1'].nunique()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['total'].max()\nans = answer(df)",
    "{\n    \"solution\": \"df[(df['generation'] == 3)]['number'].count()\"\n}\n\n\nInput DataFrame columns: ['gender', 'age', 'glasses', 'friends', 'salary', 'budget', 'website', 'movie_choice', 'sport_choice', 'finance_choice', 'music', 'tv_shows', 'books', 'likes_cars', 'likes_stamps', 'likes_robots', 'likes_gaming', 'likes_knowledge', 'likes_books', 'likes_movies', 'likes_music', 'likes_videogames', 'likes_coffee']\nQuestion: What percentage of females have red glasses and like knowledge?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[(df['gender'] == 'female') & (df['glasses'] == 'red')]['likes_knowledge'].mean()\"\n}\n\n\nInput DataFrame columns: ['name', 'age', 'gender', 'location', 'job', 'hometown']\nQuestion: How many males are in the dataset from the location they listed as their hometown?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[(df['gender'] == 'male')]['location'].eq(df['hometown']).sum()\"\n}\n\n\nInput DataFrame columns: ['salary', 'friends', 'budget']\nQuestion: What is the mean percentage of friends that are equal to or over 25 percent of their salary?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['friends'].gt(df['salary'] * 0.25).mean()\"\n}\n\n\n\n## 1.2. Data exploration\n\nAs an input you will receive a pandas DataFrame. The DataFrame columns are:\n\n* id - Unique identifier from the dataset.\n* id_owner - Unique identifier from the dataset.\n* first_name - First name from the dataset.\n* last_name - Last name from the dataset.\n* gender - Gender from the dataset.\n* age - Age from the dataset.\n* city - City from the dataset.\n* country - Country from the dataset",
    "global ans\n\ndef answer(df):\n    return df['attack'].mean()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['defense'] == df['defense'].max()]['type1']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['speed'] == df['speed'].min()]['name']\nans = answer(df)",
    "{\n    \"solution\": \"df[df['Legendary'] == True]['type1'].mode().iloc[0]\"\n}\n\n\nInput DataFrame columns: ['X', 'Y']\nQuestion: What is the distance between the point (20, 20) and each point in the data?\nExpected return type: series\n\nCode that calculates the answer:\n{\n    \"solution\": \"np.sqrt((df['X'] - 20)**2 + (df['Y'] - 20)**2)\"\n}\n\n\n## D. Pandas with `lambda`\n\nComplete the following function without using a loop or creating an additional column. The function should output a pandas DataFrame.\n\nInput DataFrame columns: ['number', 'name', 'type1', 'type2', 'total', 'hp', 'attack', 'defense', 'sp_attack', 'sp_defense', 'speed', 'generation', 'legendary']\nQuestion: What pok\u00e9mon are legendary and do not have the type \"dragon\" or \"flying\"?\nExpected return type: DataFrame\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[lambda df: (df['Legendary'] == True) & (df['type1'] != 'dragon') & (df['type2'] != 'flying')]\"\n}\n\n\n## E. Plotting \n\nComplete the following plot and describe the key features.\n\npython\nimport matplotlib.pyplot as plt\nimport plotly.express as px\n\ndf = pd.read_csv('https://bit.ly/3skhm99')\nfig = px.scatter(df, x='set', y='mass (g)', animation_frame='year', width=600, height=600, size='mass (g)', opacity=0.8, color='sex')\nfig.show()\n\n\nDescribe the key features of the question:\n- Plot the weight (mass) of each animal over time, color-coded by sex, with each year being a frame\n- The weight of most animals has increased over time\n- The weight of each sex generally follows the same pattern over time\n- There is an outlier year that is significantly different from the rest",
    "global ans\n\ndef answer(df):\n    return df[df['sp_attack'] == df['sp_attack'].max()]['name'].iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values(by='total', ascending=False)['name'][:3]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('hp')[:5]['name']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['type1'].value_counts().nlargest(2).index.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['generation'] == 2].sort_values(by=['attack'], ascending=False)['name'].head(6).tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('sp_defense', ascending=False)['sp_defense'].iloc[:5].tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['legendary'] == True]['defense'].nsmallest(2).tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['generation'] == 4]['speed'].nlargest(2)\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['legendary'] == False].sort_values(by='total').head(6)['total'].tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Extraversion'].idxmax(), 'Extraversion'] > df.loc[df['Agreeableness'].idxmax(), 'Agreeableness']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Openness'].idxmax(), 'Profession'] == df.loc[df['Conscientousness'].idxmax(), 'Profession']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['Profession'] == df['Profession'].min()]['Emotional_Range'].min() == df[df['Profession'] == df['Profession'].min()]['Conversation'].min()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Openness to Change'].mean() > df['Hedonism'].mean()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Self-enhancement'].idxmax(), 'Self-enhancement']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return len(df[df['Emotional_Range'] > 0.5]['Profession'])\nans = answer(df)",
    "{\n    \"solution\": \"df[df['n'].idxmax()]['Extraversion'].mean()\"\n}\n\nInput DataFrame columns: ['year', 'sex', 'births']\nQuestion: Which year had the highest total number of births?\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['births'].idxmax(), 'year']\"\n}\n\nInput DataFrame columns: ['name', 'gender', 'count']\nQuestion: How many records are in the dataset?\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['name'].count()\"\n}\n\nInput DataFrame columns: ['name', 'gender', 'count']\nQuestion: Which is the most popular name of all time? (e.g. excluding those that only appear once in the dataset)?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['count'].idxmax(), 'name']\"\n}\n\nInput DataFrame columns: ['country', 'city', 'latitude', 'longitude']\nQuestion: Which city has the largest number of countries represented?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.iloc[df['country'].groupby(df['city']).transform('count').idxmax()]\"\n}\n\nInput DataFrame columns: ['country', 'city', 'latitude', 'longitude']\nQuestion: Which city has the smallest number of countries represented?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.iloc[df['country'].groupby(df['city']).transform('count').idxmin()]\"\n}\n\nInput DataFrame columns: ['City', 'Type', 'StartDate', 'EndDate', 'MaxAttendees', 'MeanAttendees']\nQuestion: Which event in 2019 had the largest number of attendees?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df.loc[df['EndDate'].str.contains('2019'), 'MaxAttendees'].idxmax(), 'City",
    "global ans\n\ndef answer(df):\n    return df['Self-transcendence'].min()\nans = answer(df)",
    "{\n    \"solution\": \"df.groupby('Profession')['Conscientiousness'].mean().sort_values(ascending=False).index[0]\"\n}\n\nInput DataFrame columns: ['ID', 'Temperature', 'Pressure', 'Humidity', 'WindSpeed', 'WindBearing', 'Latitude', 'Longitude', 'date', 'time', 'year', 'month', 'day', 'hour', 'dayofweek', 'quarter', 'dayofyear', 'dayofmonth', 'weekofyear']\nQuestion: Is there any evidence that the weather is getting warmer?\nExpected return type: boolean\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['Temperature'].rolling(30).mean().diff().any()\"\n}\ndef q1():\n    df = pd.read_csv('https://raw.githubusercontent.com/LambdaSchool/DS-Unit-1-Sprint-1-Dealing-With-Data/master/module4-database-intro/database-intro/db-company-data/db-company-data.csv')\n    return df.loc[df['finalWorth'].idxmax(), 'selfMade']\ndef q2():\n    df = pd.read_csv('https://raw.githubusercontent.com/LambdaSchool/DS-Unit-1-Sprint-1-Dealing-With-Data/master/module4-database-intro/database-intro/db-company-data/db-company-data.csv')\n    return df[df['Survived'] == 1]['Pclass'].mode().iloc[0]\ndef q3():\n    df = pd.read_csv('https://raw.githubusercontent.com/LambdaSchool/DS-Unit-1-Sprint-1-Dealing-With-Data/master/module4-database-intro/database-intro/db-company-data/db-company-data.csv')\n    return df.groupby('Profession')['Conscientiousness'].mean().sort_values(ascending=False).index[0]\ndef q4():\n    df = pd.read_csv('https://raw.githubusercontent.com/LambdaSchool/DS-Unit-1-Sprint-1-Dealing-With-Data/master/module4-database-intro/",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Hedonism'].idxmin(), 'Profession']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Emotional_Range'].idxmax(), 'Profession']\nans = answer(df)",
    "{\n    \"solution\": \"'Profession' column with the highest count\"\n}\n\n\nInput DataFrame columns: ['value']\nQuestion: What is the minimum value in the 'value' column?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['value'].min()\"\n}\n\n\nInput DataFrame columns: ['First Name', 'Last Name', 'Title', 'Department', 'Salary']\nQuestion: What is the average salary of all employees?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['Salary'].mean()\"\n}\n\n\nInput DataFrame columns: ['First Name', 'Last Name', 'Gender', 'Salary']\nQuestion: What is the median salary of all employees grouped by gender?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('Gender')['Salary'].median().loc['male']\"\n}\n\n\nInput DataFrame columns: ['Title', 'Department', 'No_of_employees', 'Salary']\nQuestion: What is the maximum number of employees working in the same department?\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('Department')['No_of_employees'].max().max()\"\n}\n\n\nInput DataFrame columns: ['Name', 'Gender', 'Earnings']\nQuestion: What is the average earnings of all employees grouped by gender?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('Gender')['Earnings'].mean().unstack().loc['female']\"\n}\n\n\nInput DataFrame columns: ['Name', 'Gender', 'Earnings']\nQuestion: Which female employee has the highest earnings?\nExpected return type: str\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['Earnings'].idxmax(), 'Name']\"\n}\n\n\nInput DataFrame columns: ['Employee Name', 'Department', 'Salary', 'Earnings']\nQuestion: Which department has the highest percentage increase (Earning",
    "global ans\n\ndef answer(df):\n    return df.sort_values(by='Openness', ascending=False)['Profession'].unique()[:3]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('Agreeableness').head(4)['Profession'].values.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values(by=['Conversation'], ascending=False).head()['Profession'].values.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.nlargest(2, 'Self-enhancement')['Profession'].to_list()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.groupby('Profession')['Openness to Change'].apply(list).apply(lambda x: sorted(x, reverse=True)[:3]).reset_index().sort_values(by='Profession', ascending=False).to_dict()['Openness to Change']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Emotional_Range'].nsmallest(4).tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.nlargest(5, 'Extraversion')['Extraversion'].to_list()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('Self-transcendence').index[0:6].tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['title'].str.lower().str.contains('communication').any()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['organization'] == 'IBM', 'id']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['abstract'].str.contains('software').any()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['type'].str.contains('design').any()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return len(df.groupby('organization').ngroup())\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['num_claims'].mean()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['num_claims'].max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['type'] == 'utility'].shape[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['num_claims'] == df['num_claims'].max()]['organization']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['kind'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['lang'].unique()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.groupby('graphext_cluster')['target'].idxmax()[:1].values\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.groupby(['organization'])['num_claims'].sum().sort_values(ascending=False).head(3).index.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['type'].value_counts().head(2).index.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['kind'].value_counts().index[0:2].tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['graphext_cluster'].value_counts().nsmallest(2).index.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['num_claims'].value_counts().sort_values(ascending=False).head(4).index\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('num_claims', ascending=False)[['id', 'num_claims']].drop_duplicates(keep='first')['id'].to_numpy().tolist()[0:3]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[(df['kind'] == 'S1') | (df['kind'] == 'B2')]['num_claims'].median()\nans = answer(df)",
    "{\n    \"solution\": \"df['ID'].sort_values()[-3:].tolist()\"\n}\n\n\npython\ndef solution(df):\n    #your code\n\nassert solution(df) == expected_return_type\n\n\npython\ndef solution(df):\n    #your code\n\nassert solution(df) == expected_return_type\n\n\npython\ndef solution(df):\n    #your code\n\nassert solution(df) == expected_return_type\n\n\npython\ndef solution(df):\n    #your code\n\nassert solution(df) == expected_return_type\n\n\n\n# coding: utf-8\n\n# # Introduction\n# \n# In this case study, we will analyze data about terrorism. We will use the data to find patterns that could help predict future terrorist attacks.\n# \n# When we open the data file, we find that each row is a terrorist incident. Each column represents information about an incident, including the terrorist group that committed it, the number of people it affected, the number of casualties (including injuries and deaths), the location, and the date. The details of each column are in the data dictionary below.\n# \n# ![dataset_image](https://dq-content.s3.amazonaws.com/251/terrorism_data_dictionary.png)\n# \n# # Understanding the data\n# \n# We'll begin by loading the terrorism data set into pandas and exploring it, to see the initial structure of the data and get a feel for the important columns.\n\n# In[2]:\n\n\nimport pandas as pd\nimport numpy as np\n\nget_ipython().run_line_magic('matplotlib', 'inline')\n\n\n# In[3]:\n\n\nterrorism_data = pd.read_csv('global_terrorism.csv',low_memory=False)\n\n\n# In[4]:\n\n\nterrorism_data.sample(10)\n\n\n# In[5]:\n\n\nterrorism_data.shape\n\n\n# # Which columns are numeric and which are categorical?\n# \n# We'll need to figure out which columns in the data set",
    "{\n    \"solution\": \"df[df['user_followers_count'].idxmax()]['user_verified']\"\n}\n\nInput DataFrame columns: ['url<gx:url>', 'id<gx:category>', 'event_name<gx:text>', 'date<gx:date>', 'status<gx:category>', 'user_id<gx:category>', 'user_name<gx:category>', 'user_screen_name<gx:text>', 'user_location<gx:text>', 'user_description<gx:text>', 'user_url<gx:url>', 'user_followers_count<gx:number>', 'user_friends_count<gx:number>', 'user_listed_count<gx:number>', 'user_created_at<gx:date>', 'user_verified<gx:boolean>', 'user_favourites_count<gx:number>', 'user_statuses_count<gx:number>', 'user_lang<gx:category>', 'retweet_count<gx:number>', 'favorite_count<gx:number>', 'entities_urls_count<gx:number>', 'in_reply_to_user_id<gx:category>', 'in_reply_to_status_id<gx:category>', 'in_reply_to_screen_name<gx:text>', 'source<gx:category>', 'text<gx:text>', 'geo<gx:category>', 'coordinates<gx:list[number]>', 'place<gx:category>', 'retweeted_status_id<gx:category>', 'retweeted_status_user_id<gx:category>', 'retweeted_status_user_screen_name<gx:text>', 'retweeted_status_tweet_created_at<gx:date>', 'retweeted_status_tweet_id<gx:category>', 'retweeted_status_tweet_source<gx:category>', 'retweeted_status_tweet_text<gx:text>', 'retweeted_status_tweet_lang<gx:category>', 'sentiment<gx:category>', 'event_id<gx:number>']\nQuestion: What was the average sentiment of all tweets in the dataset?\nExpected return type: number\n\nCode that calculates the answer:\njson",
    "{\n    \"solution\": \"df.loc[df['author_favourites_count'].idxmax(), 'author_retweet_count'] == df.loc[df['author_favourites_count'].idxmax(), 'author_favourites_count']\"\n}\n\n\n\n## 3) Matrix multiplication\n\nThe function must only be a single line long and use element-wise operations, vectorized operations and dot product.\n\nInput DataFrame columns: ['matrix']\nQuestion: Calculate the element-wise multiplication between the matrices\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"(df.loc[0, 'matrix'].values * (df.loc[1, 'matrix'].values.T)).ravel().astype(int)\"\n}\n\n\nInput DataFrame columns: ['matrix']\nQuestion: Calculate the element-wise multiplication between the matrices\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"(df.loc[0, 'matrix'].values * (df.loc[1, 'matrix'].values.T)).ravel().astype(int)\"\n}\n\n\n## 4) Matrix multiplication\n\nCalculate the dot product between the two matrices.\n\nInput DataFrame columns: ['matrix1', 'matrix2']\nQuestion: Calculate the dot product between the matrices\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"(df.loc[0, 'matrix1'].values @ df.loc[0, 'matrix2'].values)\"\n}\n\n\n## 5) Matrix multiplication\n\nCalculate the dot product between the two matrices.\n\nInput DataFrame columns: ['matrix1', 'matrix2']\nQuestion: Calculate the dot product between the matrices\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"(df.loc[0, 'matrix1'].values @ df.loc[0, 'matrix2'].values)\"\n}\n\n\n## 6) Chess board\n\nThe function must only be a single line long and use element-wise operations, vectorized operations and dot product.\n\nInput DataFrame columns: ['row', 'col']\nQuestion: Generate a",
    "{\n    \"solution\": \"df.groupby('mention_names').sum()['retweets'].idxmax() == df.groupby('mention_names').sum()['retweets'].max()\"\n}\n\n\n\n## Notes:\n\n### Python Resources:\n\n* [Python 3](https://realpython.com/installing-python/)\n* [Python packages](https://packaging.python.org/tutorials/installing-packages/)\n* [Python Pandas](https://pandas.pydata.org/)\n/js_solutions/js_solutions.py\nimport requests\nfrom bs4 import BeautifulSoup\n\nurl = 'https://www.cnet.com/windows/'\n\nheaders = {\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36',\n    'referrer': 'https://google.com'\n}\n\npage = requests.get(url, headers=headers)\nsoup = BeautifulSoup(page.text, 'html.parser')\n\n\ndef get_content(category):\n    \"\"\"\n    This function returns the first content of a given category \n    \"\"\"\n    if category == \"latest news\":\n        try:\n            content = soup.find('section', class_='LatestNews_a32a-4wXQR2').find('article')\n        except AttributeError:\n            content = \"No latest news\"\n            return content\n\n    if category == \"reviews\":\n        try:\n            content = soup.find('section', class_='Reviews_f3e2-4xU78O').find('article')\n        except AttributeError:\n            content = \"No reviews\"\n            return content\n\n    if category == \"trending\":\n        try:\n            content = soup.find('section', class_='Trending_c5d7-4R4f0p').find('article')\n        except AttributeError:\n            content = \"No trending\"\n            return content\n\n    content_el = content.find_all('div', recursive=False)[0]\n\n    return content_el\n\n\ndef get_content_token(category):\n    \"\"\"\n    This function returns the first token of a given category",
    "{\n    \"solution\": \"df.loc[df['retweets'].idxmax(), 'replies'] > df.loc[df['replies'].idxmax(), 'replies']\"\n}\n\n\nInput DataFrame columns: ['x', 'y', 'z']\nQuestion: What is the sum of all values in the 'x' column?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['x'].sum()\"\n}\n\n\nInput DataFrame columns: ['x', 'y', 'z']\nQuestion: What is the mean of the 'x' column?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['x'].mean()\"\n}\n\n\nInput DataFrame columns: ['x', 'y', 'z']\nQuestion: What is the index of the row with the largest value in the 'z' column?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['z'].idxmax()\"\n}\n\n\nInput DataFrame columns: ['x', 'y', 'z']\nQuestion: What is the difference between the mean and standard deviation of the 'z' column?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['z'].mean() - df['z'].std()\"\n}\n\n\nInput DataFrame columns: ['x', 'y', 'z']\nQuestion: What is the index of the row with the second largest value in the 'z' column?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"s = sorted(df['z'])\\nindex = s.index(s[-2])\"\n}\n\n\nInput DataFrame columns: ['x', 'y', 'z']\nQuestion: What is the value in the 'z' column of the row with the second largest value in the 'z' column?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"s = sorted(df['z'])\\nvalue = s[-2]\"\n}\n\n    return res",
    "{\n    \"solution\": \"df['user_followers_count'].max()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:number>', 'user_followers_count<gx:number>', 'user_following_count<gx:number>', 'user_listed_count<gx:number>', 'user_tweets_count<gx:number>', 'user_verified<gx:boolean>', 'user_location<gx:text>', 'lang<gx:category>', 'type<gx:category>', 'text<gx:text>', 'date<gx:date>', 'mention_ids<gx:list[category]>', 'mention_names<gx:list[category]>', 'retweets<gx:number>', 'favorites<gx:number>', 'replies<gx:number>', 'quotes<gx:number>', 'links<gx:list[url]>', 'links_first<gx:url>', 'image_links<gx:list[url]>', 'image_links_first<gx:url>', 'rp_user_id<gx:category>', 'rp_user_name<gx:category>', 'location<gx:text>', 'tweet_link<gx:url>', 'source<gx:text>', 'search<gx:category>']\nQuestion: How many unique languages are there in the dataset?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['lang'].nunique()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:number>', 'user_followers_count<gx:number>', 'user_following_count<gx:number>', 'user_listed_",
    "{\n    \"solution\": \"len(df.loc[df['favorites'] > 10000, 'author_id'].unique())\"\n}\n\n\nInput DataFrame columns: ['day_of_week', 'release_date', 'release_year', 'movie', 'color', 'director', 'actor_1_name', 'actor_2_name', 'actor_3_name', 'genres', 'duration_minutes', 'country', 'content_rating', 'budget', 'title_year', 'imdb_score', 'gross']\nQuestion: What is the most common country for a movie with a budget of more than $100,000,000?\nExpected return type: text\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['budget'] > 100000000, 'country'].mode().iloc[0]\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:number>', 'user_followers_count<gx:number>', 'user_following_count<gx:number>', 'user_listed_count<gx:number>', 'user_tweets_count<gx:number>', 'user_verified<gx:boolean>', 'user_location<gx:text>', 'lang<gx:category>', 'type<gx:category>', 'text<gx:text>', 'date<gx:date>', 'mention_ids<gx:list[category]>', 'mention_names<gx:list[category]>', 'retweets<gx:number>', 'favorites<gx:number>', 'replies<gx:number>', 'quotes<gx:number>', 'links<gx:list[url]>', 'links_first<gx:url>', 'image_links<gx:list[url]>', 'image_links_first<gx:url>', 'rp_user_id<gx:category>', 'rp_user_name<gx:",
    "{\n    \"solution\": \"df[df['retweets'] == df['retweets'].max()]['retweets'].iloc[0]\"\n}\n\n\n\nThe function should return the requested information in the expected type.\n\nYou should use the following code to evaluate your function for a single test.\n\nimport pandas as pd\nfrom functions import pandas_function\n\ndef test_pandas(df, function, question, expected_type):\n    \"\"\"Test pandas function for assigment.\"\"\"\n    try:\n        answer = function(df, question)\n        assert answer == expected_type, \"Expected {} for question, got {}: {}\".format(expected_type, type(answer), answer)\n        print(f\"\\033[92m{question} - Correct!\")\n    except AssertionError:\n        print(f\"\\033[91m{question} - Incorrect!\")\n\n    return answer\n\ndf = pd.read_csv('data/pandas_example.csv')\ndf = df.astype('category')\ntest_pandas(df, pandas_function, \"Is the person with the highest net worth self-made?\", bool)\ntest_pandas(df, pandas_function, \"Which passenger class has the highest number of survivors?\", 'category')\ntest_pandas(df, pandas_function, \"How many retweets does the most retweeted tweet have?\", int)\n\n\n# Challenge 2\n\nYou are a data scientist at a large firm working for a large company. You are given the following dataset:\n\npd.read_csv('data/employee_attrition.csv')\n\n\nYour goal is to understand what makes an employee leave and to create a function that returns a \"risk score\" for each employee.\n\nThis \"risk score\" should be calculated as follows:\n\n- If an employee has any of the following attributes: Is the employee an active veteran? Is the employee a sexual harasser? Does the employee have a disability? Does the employee have a criminal record? Does the employee have a mental health issue? Is the employee a physical dependable? Is the employee an arrested felon? Is the employee a military dependent? Is the employee a spamming/scamming employee? Is the employee a smo",
    "{\n    \"solution\": \"df.groupby('mention_ids').count()['mentions'].idxmax()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:number>', 'user_followers_count<gx:number>', 'user_following_count<gx:number>', 'user_listed_count<gx:number>', 'user_tweets_count<gx:number>', 'user_verified<gx:boolean>', 'user_location<gx:text>', 'lang<gx:category>', 'type<gx:category>', 'text<gx:text>', 'date<gx:date>', 'mention_ids<gx:list[category]>', 'mention_names<gx:list[category]>', 'retweets<gx:number>', 'favorites<gx:number>', 'replies<gx:number>', 'quotes<gx:number>', 'links<gx:list[url]>', 'links_first<gx:url>', 'image_links<gx:list[url]>', 'image_links_first<gx:url>', 'rp_user_id<gx:category>', 'rp_user_name<gx:category>', 'location<gx:text>', 'tweet_link<gx:url>', 'source<gx:text>', 'search<gx:category>']\nQuestion: How many times has the user 'YogiBear' been mentioned?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['mention_names'].str.contains('YogiBear')]['mention_names'].count()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:",
    "{\n    \"solution\": \"df.loc[:, 'author_followers_count'].idxmax()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:number>', 'user_followers_count<gx:number>', 'user_following_count<gx:number>', 'user_listed_count<gx:number>', 'user_tweets_count<gx:number>', 'user_verified<gx:boolean>', 'user_location<gx:text>', 'lang<gx:category>', 'type<gx:category>', 'text<gx:text>', 'date<gx:date>', 'mention_ids<gx:list[category]>', 'mention_names<gx:list[category]>', 'retweets<gx:number>', 'favorites<gx:number>', 'replies<gx:number>', 'quotes<gx:number>', 'links<gx:list[url]>', 'links_first<gx:url>', 'image_links<gx:list[url]>', 'image_links_first<gx:url>', 'rp_user_id<gx:category>', 'rp_user_name<gx:category>', 'location<gx:text>', 'tweet_link<gx:url>', 'source<gx:text>', 'search<gx:category>']\nQuestion: Which Twitter user has the most linked to Wikipedia article?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['links'].map(len).idxmax(), 'user_handler']\"\n}\n\n\nInput DataFrame columns: ['rank', 'personName', 'age', 'finalWorth', 'category', 'source', 'country', 'state', 'city', 'organization', 'selfMade', 'gender', 'birthDate', 'title', 'philanthropyScore', 'bio', 'about']\nQuestion: What is the average age of self-made billionaires?\nExpected return type: number",
    "{\n    \"solution\": \"df[df['user_favourites_count'].idxmax()]['author_name']\"\n}\nimport pandas as pd\n\ndf = pd.read_csv('data.csv')\n\ndef get_first_name(string):\n    #split string at spaces and return the first item\n    return string.split(\" \")[0]\n\ndef get_last_name(string):\n    #split string at spaces and return the last item\n    return string.split(\" \")[-1]\n\n#get first and last names\ndf['first_name'] = df['Name'].apply(get_first_name)\ndf['last_name'] = df['Name'].apply(get_last_name)# Python Bootcamp\n\nThe following list contains exercises that can be solved using the Python programming language.\n\nExercise ticket: https://app.ticketmatic.com/event/python-bootcamp-1\n\nPresentation: https://slides.com/mikeelliott777/deck-1/live\n\n## Setup\n\nThese exercises are created with Python version 3.8.0.\n\nThe packages that are used in this bootcamp are:\n\n`pandas` version 1.0.5\n\n`scikit-learn` version 0.23.1\n\n`matplotlib` version 3.2.1\n\n`seaborn` version 0.10.1\n\nYou can download all these packages with the following command:\n\n`python -m pip install pandas scikit-learn matplotlib seaborn`\n\nIf you do not have Python installed, download it here: https://www.python.org/downloads/\n\n## Exercises\n\nThe following exercises will be solved in the following files:\n\n| Exercise | File Name |\n| ---- | ----------- |\n| Exercise 1 | [00_exercise_1.py](00_exercise_1.py) |\n| Exercise 2 | [00_exercise_2.py](00_exercise_2.py) |\n| Exercise 3 | [00_exercise_3.py](00_exercise_3.py) |\nimport pandas as pd\n\ndf = pd.read_csv('data.csv",
    "{\n    \"solution\": \"df['author_name'].value_counts().index[0]\"\n}\n\n\nInput DataFrame columns: ['id', 'name', 'license', 'license_start_date', 'county', 'state', 'city', 'location', 'location_type', 'location_lat', 'location_long', 'location_accuracy', 'address', 'apt', 'street', 'cross_street', 'zip', 'phone', 'website', 'hours_open', 'hours_closed', 'todays_hours', 'todays_hours_24hr', 'todays_hours_notes', 'todays_hours_restrictions', 'todays_hours_restrictions_notes', 'todays_hours_sunday', 'todays_hours_sunday_24hr', 'todays_hours_sunday_notes', 'todays_hours_sunday_restrictions', 'todays_hours_sunday_restrictions_notes', 'todays_hours_monday', 'todays_hours_monday_24hr', 'todays_hours_monday_notes', 'todays_hours_monday_restrictions', 'todays_hours_monday_restrictions_notes', 'todays_hours_tuesday', 'todays_hours_tuesday_24hr', 'todays_hours_tuesday_notes', 'todays_hours_tuesday_restrictions', 'todays_hours_tuesday_restrictions_notes', 'todays_hours_wednesday', 'todays_hours_wednesday_24hr', 'todays_hours_wednesday_notes', 'todays_hours_wednesday_restrictions', 'todays_hours_wednesday_restrictions_notes', 'todays_hours_thursday', 'todays_hours_thursday_24hr', 'todays_hours_thursday_notes', 'todays_hours_thursday_restrictions', 'todays_hours_thursday_restrictions_notes', 'todays_hours_friday', 'todays_hours_friday_24hr', 'todays_hours_friday_notes', 'todays_hours_friday_restrictions', 'tod",
    "{\n    \"solution\": \"df[df['retweets'].idxmax()]['author_name']\"\n}\n\n\n\n### 2. Data extraction - 150 points\n\nIn this problem, you will be working with the olympic medals dataset from Kaggle: https://www.kaggle.com/the-guardian/olympic-games.\n\nThe dataset contains data from the medallist at every edition of the olympic games, from Athens 1896 to Rio 2016.\n\nThis dataset contains 28129 relevant records (28128 rows and 14 columns).\n\nEach row in the dataset has information about an individual medal win. \nThe columns are:\n1. City - City where the olympic games took place\n2. Edition - Year the games took place\n3. Sport - Sport the player participated in\n4. Discipline - Category of the sport\n5. Athlete - Athlete's full name\n6. Country - Country the athlete represents\n7. Gender - Gender of the athlete\n8. Event - Event in which the athlete participated\n9. Medal - Type of medal (\"Gold\", \"Silver\", \"Bronze\")\n\n\nIn the problems below, find the requested information using the dataset and pandas operations ONLY. If the requested information cannot be obtained in one line, it's fine to use multiple.\n\nE.g.\npy\n# In the code below, calculate the number of silver medalists in 100m hurdles in 1920 Athens.\n# The solution should ONLY require one line of code (unless there's a tricky way to do it that I forgot).\n\n# Code that calculates the number of silver medalists in 100m hurdles in 1920 Athens:\n{\n    \"solution\": \"df[(df['Edition'] == 1920) & (df['Sport'] == 'Athletics') & (df['Discipline'] == '100m hurdles') & (df['Medal'] == 'Silver')].shape[0]\"\n}\n\n# Code",
    "{\n    \"solution\": \"df['author_name'].value_counts().head(3).index.tolist()\"    \n}\n\n\n# For a short code challenge, you are tasked with completing a function that takes in a string as input and returns a df of the frequencies of each word in the string.\n\npython\nimport pandas as pd\nimport numpy as np\n\ndef word_frequency(input_str):\n    \"\"\"\n    Simple function that takes in a string and returns a df of the frequencies of each word in the string.\n\n    Input:\n        input_str: the string to analyze\n\n    Output:\n        word_freq: a df with columns [\"word\", \"frequency\"]\n    \"\"\"\n    # TODO: Your code goes here\n\n    return word_freq\n\n# Example use\ninput_str = \"The New York Times is an American daily news website with a focus on international news. The Times has been based in New York City since 1851. The Times is well known for its investigative journalism and for its journalistic statements in support of free speech.\"\nword_freq = word_frequency(input_str)\nprint(word_freq)\n\n\n## Expected Output\n![Expected Output](example_1.png)\n\n# In a second short code challenge, you are tasked with completing a function that calculates the distance between two pairs of points and returns a dict of the unique distances between the pairs.\n\npython\nimport pandas as pd\nimport numpy as np\n\ndef get_unique_distances(a, b):\n    \"\"\"\n    Function that calculates the distance between two pairs of points and returns a dict of the unique distances between the pairs.\n\n    Input:\n        a: a df of points with columns [\"x\", \"y\"]\n        b: a df of points with columns [\"x\", \"y\"]\n\n    Output:\n        unique_distances: a dict of the unique distances between the pairs of points\n    \"\"\"\n    # TODO: Your code goes here\n    return unique_distances\n\n# Example use\na = pd.DataFrame(data=[[0,0], [1,0], [0,1], [0.5,0.5]], columns=['x', 'y'])\nb = pd.DataFrame(data=[[1,1], [1,0], [0,1], [1",
    "{\n    \"solution\": \"df[['author_id', 'favorites']].groupby('author_id').sum().nlargest(4, 'favorites')['author_id'].values\"\n}\n\n\nInput DataFrame columns: ['id<gx:number>', 'lat<gx:number>', 'lng<gx:number>', 'city<gx:text>', 'state_code<gx:category>', 'country_code<gx:category>', 'state<gx:text>', 'country<gx:text>', 'wiki_link<gx:url>', 'web_link<gx:url>', 'county<gx:text>']\nQuestion: What is the country code of the state with the most inhabitants?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['state_code'].value_counts().index[0]\"\n}\n\n\nInput DataFrame columns: ['id<gx:number>', 'name<gx:text>', 'type<gx:category>', 'location_id<gx:number>', 'location_name<gx:text>', 'location<gx:text>', 'code<gx:text>', 'continent_code<gx:category>', 'country_code<gx:category>', 'country_name<gx:text>', 'state_code<gx:category>', 'state_name<gx:text>', 'county<gx:text>', 'postal_code<gx:text>', 'date_created<gx:date>', 'date_updated<gx:date>', 'date_certified<gx:date>', 'web_link<gx:url>', 'wiki_link<gx:url>']\nQuestion: What is the country code of the country with the most cities?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['country_code'].value_counts().index[0]\"\n}\n\n\nInput DataFrame columns: ['region<gx:category>', 'blog_url<gx:url>', 'blog_name<gx:text>', 'email<gx:text>', 'hireable<gx:boolean>', 'location<gx:text>', 'name<gx:text>', 'twitter_username<gx:text>', 'phone<gx:text>',",
    "{\n    \"solution\": \"df['mention_names'].explode().value_counts()[df['mention_names'].explode().value_counts() == df['mention_names'].explode().value_counts().max()].index.tolist()[:4]\"\n}\n\n\nInput DataFrame columns: ['tweet_id', 'text', 'language', 'retweet_count', 'favorite_count', 'user_id', 'user_name', 'created_at', 'mentioned_user_count', 'mentioned_user_ids', 'location', 'retweet_tweet_ids', 'quote_tweet_ids']\nQuestion: What are the 10 most frequently used hashtags?\nExpected return type: list[category]\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['text'].str.extractall(r'\\\\#([^\\\\s]+)').groupby(0).count().nlargest(10, 1).index.tolist()\"\n}\n\n\nInput DataFrame columns: ['tweet_id', 'text', 'language', 'retweet_count', 'favorite_count', 'user_id', 'user_name', 'created_at', 'mentioned_user_count', 'mentioned_user_ids', 'location', 'retweet_tweet_ids', 'quote_tweet_ids']\nQuestion: Which tweet has the most mentioned users?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['mentioned_user_count'].max()\"\n}\n\n\nInput DataFrame columns: ['tweet_id', 'text', 'language', 'retweet_count', 'favorite_count', 'user_id', 'user_name', 'created_at', 'mentioned_user_count', 'mentioned_user_ids', 'location', 'retweet_tweet_ids', 'quote_tweet_ids']\nQuestion: What is the average retweet count?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['retweet_count'].mean()\"\n}\n\n\nInput DataFrame columns: ['tweet_id', 'text', 'language', 'retweet_count', 'favorite_count',",
    "{\n    \"solution\": \"df.groupby('author_id')['retweets'].sum().sort_values(ascending=False).head(2).index.tolist()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'step<gx:number>', 'timestamp<gx:date>', 'nodeid<gx:category>', 'infected<gx:boolean>']\nQuestion: Which node has the highest infected score at the start of the simulation?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['step'] == 0].groupby('nodeid')['infected'].sum().idxmax()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'start_lat<gx:number>', 'start_lng<gx:number>', 'end_lat<gx:number>', 'end_lng<gx:number>', 'distance<gx:number>', 'duration<gx:number>']\nQuestion: Which route has the longest duration?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('id')['duration'].sum().idxmax()\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'start_lat<gx:number>', 'start_lng<gx:number>', 'end_lat<gx:number>', 'end_lng<gx:number>', 'distance<gx:number>', 'duration<gx:number>']\nQuestion: Which route has the longest distance?\nExpected return type: category\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('id')['duration'].sum().idxmax()\"\n}\n\n\nInput DataFrame columns: ['Personality I', 'Personality E', 'Personality N', 'Personality S', 'Personality T', 'Personality J', 'Personality P', 'Personality Status']\nQuestion: Are there more 'extroverts' on the data than 'introverts'?\nExpected return type: boolean\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.Personality.value_counts().index.tolist() == ['E', 'I']\"\n}",
    "{\n    \"solution\": \"df.sort_values(by='user_followers_count', ascending=False)['user_followers_count'].iloc[:3].tolist()\"\n}\n\n\nInput DataFrame columns: ['text<gx:text>', 'Hashtags<gx:list[category]>']\nQuestion: What are the top 3 most popular hashtags in the dataset?\nExpected return type: list[category]\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.explode('Hashtags')['Hashtags'].value_counts(ascending=False).index[:3].tolist()\"\n}\n\n\nfrom typing import List, Union, Tuple, Dict\nimport pandas as pd\nimport math\n\n\ndef weighted_mean(series: pd.Series) -> pd.Series:\n    \"\"\"\n    Returns the weighted mean of a series taking into account the number of observations.\n\n    :param series: The series containing the values for which the weighted mean is calculated.\n    :return: The weighted mean of the values in the given series.\n    \"\"\"\n    weight = series.shape[0] / series.count()\n    return series.sum() * weight\n\n\ndef weighted_median(series: pd.Series) -> pd.Series:\n    \"\"\"\n    Returns the weighted median of a series taking into account the number of observations.\n\n    :param series: The series containing the values for which the weighted median is calculated.\n    :return: The weighted median of the values in the given series.\n    \"\"\"\n    if series.count() == 0:\n        return math.nan\n    weight = series.shape[0] / series.count()\n    sorted_series = series.sort_values()\n    lower_index = math.floor(weight / 2) - 1\n    upper_index = math.ceil(weight / 2) - 1\n    if upper_index < 0 or lower_index >= series.shape[0]:\n        return math.nan\n    elif upper_index == lower_index:\n        return sorted_series.iloc[lower_index]\n    else:\n        return (sorted_series.iloc[upper_index] + sorted_series.iloc[lower_index]) / 2\n\n\ndef weighted_percentile(series: pd.Series, percentile: Union[Tuple[int",
    "{\n    \"solution\": \"df['favorites'].nlargest(3)\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:number>', 'user_followers_count<gx:number>', 'user_following_count<gx:number>', 'user_listed_count<gx:number>', 'user_tweets_count<gx:number>', 'user_verified<gx:boolean>', 'user_location<gx:text>', 'lang<gx:category>', 'type<gx:category>', 'text<gx:text>', 'date<gx:date>', 'mention_ids<gx:list[category]>', 'mention_names<gx:list[category]>', 'retweets<gx:number>', 'favorites<gx:number>', 'replies<gx:number>', 'quotes<gx:number>', 'links<gx:list[url]>', 'links_first<gx:url>', 'image_links<gx:list[url]>', 'image_links_first<gx:url>', 'rp_user_id<gx:category>', 'rp_user_name<gx:category>', 'location<gx:text>', 'tweet_link<gx:url>', 'source<gx:text>', 'search<gx:category>']\nQuestion: What are the top 5 urls in the dataset that are of type image?\nExpected return type: list[url]\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['type'] == 'image', 'image_links_first']\"\n}\n\n\nInput DataFrame columns: ['id<gx:category>', 'author_id<gx:category>', 'author_name<gx:category>', 'author_handler<gx:category>', 'author_avatar<gx:url>', 'user_created_at<gx:date>', 'user_description<gx:text>', 'user_favourites_count<gx:number>', 'user_followers_count",
    "{\n    \"solution\": \"df.iloc[:, 15:19].dropna().astype(int).sum(axis=1).nlargest(5).tolist()\"\n}\n\n\nInput DataFrame columns: ['Title', 'Duration', 'Production Budget', 'Worldwide Gross', 'Discipline', 'Release Year', 'Link to IMDb Page', 'Language', 'Country', 'Link to FreeFull Movie Page', 'Original Language', 'Rating', 'Votes', 'Gross USA', 'Gross Canada', 'Gross Other Countries', 'Gross Worldwide', 'Link to Wikipedia', 'Genre', 'Directors', 'Stars', 'Runtime']\nQuestion: How many movies do not have a rating?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['Rating'].isna().sum()\"\n}\n\n\nInput DataFrame columns: ['f1_cat', 'f2_cat', 'f3_cat', 'f4_cat', 'f5_cat', 'f6_cat', 'f7_cat', 'f8_cat', 'f9_cat', 'f10_cat', 'f11_cat', 'f1_num', 'f2_num', 'f3_num', 'f4_num', 'f5_num', 'f6_num', 'f7_num', 'f8_num', 'f9_num', 'f10_num', 'f11_num', 'f12_cat', 'f13_cat', 'f14_cat', 'f15_cat', 'f16_cat', 'f17_cat', 'f18_cat', 'f19_cat', 'f20_cat', 'f21_cat', 'f22_cat', 'f23_cat', 'f24_cat', 'f25_cat', 'f1_num_2', 'f2_num_2', 'f3_num_2', 'f4_num_2', 'f5_num_2', 'f6_num_2', 'f7_num_2', 'f8_num_",
    "{\n    \"solution\": \"df['retweets'].sort_values(ascending=False).head(2).tolist()\"\n}\n\n\nInput DataFrame columns: ['id', 'author_id', 'author_name', 'author_handler', 'author_avatar', 'user_created_at', 'user_description', 'user_favourites_count', 'user_followers_count', 'user_following_count', 'user_listed_count', 'user_tweets_count', 'user_verified', 'user_location', 'lang', 'type', 'text', 'date', 'mention_ids', 'mention_names', 'retweets', 'favorites', 'replies', 'quotes', 'links', 'links_first', 'image_links', 'image_links_first', 'rp_user_id', 'rp_user_name', 'location', 'tweet_link', 'source', 'search']\nQuestion: What are the top 2 lowest numbers of favorites a tweet in the dataset has?\nExpected return type: list[number]\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['favorites'].sort_values().head(2).tolist()\"\n}\n\n\nInput DataFrame columns: ['Survived', 'Pclass', 'Name', 'Sex', 'Age', 'Siblings_Spouses Aboard', 'Parents_Children Aboard', 'Fare']\nQuestion: What is the total number of survivors?\nExpected return type: integer\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['Survived'] == 1]['Survived'].count()\"\n}\n\n\nInput DataFrame columns: ['Survived', 'Pclass', 'Name', 'Sex', 'Age', 'Siblings_Spouses Aboard', 'Parents_Children Aboard', 'Fare']\nQuestion: What is the percentage of people who did not survive?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['Survived'] == 0]['Survived'].count() / df['Survived'].count()\"\n}\n\n\nInput DataFrame columns: ['id', 'author_id',",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Loan Amount'].idxmax(), 'Loan Duration - Months']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values('Number of Existing Loans', ascending=False).iloc[0].loc['Loan Amount'] > df['Loan Amount'].max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Loan Duration - Months'].idxmax(), 'Number of Existing Loans'] == df['Number of Existing Loans'].max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Age'].max() == df['Loan Amount'].max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Loan Amount'].max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return len(df.loc[df['Number of Existing Loans'] > 1])\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Loan Duration - Months'].max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['Age'] > 50]['Age'].count()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Purpose of Loan'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Job'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Credit History'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Savings Account'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.sort_values(by=['Loan Amount'], ascending=False).head(3)['Job'].tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Loan Duration - Months'] >= 24, 'Job'].value_counts().index.to_list()[:4]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['Number of Existing Loans'] == df['Number of Existing Loans'].max()]['Job'].value_counts().head().index.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return sorted(df.sort_values(by='Age', ascending=False)['Job'][:5].unique().tolist())\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Loan Amount'].sort_values(ascending=False).head(3).tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Loan Duration - Months'].value_counts().head(4).index.to_list()\nans = answer(df)",
    "{\n    \"solution\": \"existing_loans = df['Number of Existing Loans']\\nthree_max = existing_loans.nlargest(3)\\nthree_max.reset_index(drop=True, inplace=True)\\nreturn list(three_max)\"\n}\n\n\nInput DataFrame columns: ['Survived', 'Pclass', 'Name', 'Sex', 'Age', 'Siblings_Spouses Aboard', 'Parents_Children Aboard', 'Fare']\nQuestion: How many female passengers of class 1 and class 2 survived?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[(df['Sex'] == 'female') & (df['Pclass'].isin([1, 2])) & (df['Survived'] == 1)].shape[0]\"\n}\n\n\nInput DataFrame columns: ['Survived', 'Pclass', 'Sex', 'Age', 'Siblings/Spouses Aboard', 'Parents/Children Aboard', 'Fare']\nQuestion: What is the percentage of survival based on gender, passenger class, and ticket class?\nExpected return type: pd.DataFrame (index: gender, columns: passenger class, ticket class, values: survival percentage)\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby(['Sex', 'Pclass']).apply(lambda grp: grp['Survived'].mean())\"\n}\n\n/AI-track/Ethereum/js/data.js\nfunction mapData(data) {\r\n    console.log(data);\r\n    let time = [];\r\n    let price = [];\r\n    let volume = [];\r\n    let marketCap = [];\r\n\r\n    for (let i = 0; i < data.data.length; i++) {\r\n        time.push(data.data[i][0]);\r\n        price.push(data.data[i][4]);\r\n        volume.push(data.data[i][6]);\r\n        marketCap.push(data.data[i][8]);\r\n    }\r\n\r\n    console.log(time);\r\n\r\n    let series = {\r\n        name: \"Price\",\r\n        type: \"line\",\r\n        data: price\r\n    };\r\n\r\n    let markCapSeries = {\r\n        name",
    "{\n    \"solution\": \"list(df.sort_values('Age', ascending=False).iloc[:2, 10])\"\n}\n\n\nInput DataFrame columns: ['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']\nQuestion: What is the percentage increase in the price on the day of 12/10?\nExpected return type: number\n\nCode that calculates the answer:\n{\n  \"solution\": \"100*((df.loc[df['Date'] == '12/10']['Close'].values[0] - df.loc[df['Date'] == '12/9']['Close'].values[0])/df.loc[df['Date'] == '12/9']['Close'].values[0])\"\n}\n\n\nInput DataFrame columns: ['Days', 'Money', 'Food', 'Jobs', 'Health']\nQuestion: What was the most money spent in a single day?\nExpected return type: number\n\nCode that calculates the answer:\n{\n  \"solution\": \"df.groupby('Days')['Money'].sum().max()\"\n}\n\n\nInput DataFrame columns: ['Year', 'School (s) hosted', 'State (s) hosted', 'Capital (s) hosted', 'City (s) hosted']\nQuestion: What event was held in the largest city?\nExpected return type: string\n\nCode that calculates the answer:\n{\n  \"solution\": \"df.groupby('City (s) hosted')['Year'].count().idxmax()\"\n}\n\n\nInput DataFrame columns: ['Rank', 'Name', 'Country', 'Tourism revenue (millions in 2002 PPP)', 'Continent', 'Inflation', 'Life expectancy at birth (years)', 'Road transport (passenger cars / 1000 people)', 'Income per person (GDP/capita, PPP in USD)', 'Reported HIV/AIDS cases', 'Population (2000)', 'Military expenditure (% of GDP)']\nQuestion: Is the correlation between life expectancy and tourism revenue negative or positive (Hint: another way of asking this question is is the life expectancy increasing or decreasing",
    "global ans\n\ndef answer(df):\n    return df['Calories (kcal)'].any()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Total Sugar (g)'].sum()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Total Fat (g)'].eq(0).any()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Protein (g)'].isna().all()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return len(df[df['Calories (kcal)'] > 500])\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Total Fat (g)'].mean()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['Sodium (g)'] > 1].shape[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Protein (g)'].idxmax(), 'Protein (g)']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Calories (kcal)'].idxmax()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Total Sugar (g)'].idxmax(), 'name']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Total Fat (g)'].idxmin(), 'name']\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.loc[df['Protein (g)'].idxmax(), 'name']\nans = answer(df)",
    "{\n    \"solution\": \"df['name'].nlargest(5).tolist()\"\n}\nimport pandas as pd\npeople_df = pd.read_csv('people_dataset.csv')\npeople_df.head()\nsnack_df = pd.read_csv('snack_dataset.csv')\nsnack_df.head()\n# Does the person with the highest net worth self-made?\n# True\n# Which passenger class has the highest number of survivors?\n# 1\n# Top 5 foods with the most calories\n# ['candy','cookies','pastries','chocolate','nuts']\npeople_df.columnspython\n#------------------------\n#| SOLO JUSTIFICATION |\n#------------------------\n{'solution': 'df.loc[df['finalWorth'].idxmax(), 'selfMade']'}\n{'solution': \"df[df['Survived'] == 1]['Pclass'].mode().iloc[0]\"}\n# Does the person with the highest net worth self-made?\npeople_df[people_df['finalWorth'].idxmax()]['selfMade']\n# Which passenger class has the highest number of survivors?\npeople_df[people_df['Survived'] == 1]['Pclass'].mode().iloc[0]\n# Top 5 foods with the most calories\nsnack_df['Calories (kcal)'].nlargest(5).index\nsnack_df.index\nsnack_df['name'].nlargest(5).index\nsnack_df['name'].nlargest(5).index.tolist()\nsnack_df['name'].nlargest(5).tolist()\nmust_eat_df = snack_df[(snack_df['Calories (kcal)'] > 0) & (snack_df['Total Sugar (g)'] == 0) & (snack_df['Carbohydrates (g)'] == 0)]\nmust_eat_df\nmust_eat_df['name'].nlargest(5).index.tolist()python\n#------------------------\n#| SOLO JUSTIFICATION |\n#------------------------\n{'solution': 'df['name",
    "global ans\n\ndef answer(df):\n    return df.nsmallest(3, 'Total Sugar (g)')['name'].tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df.columns[7:16].tolist() + ['name']].idxmax(axis=1).tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['Protein (g)'] < 1]['name'].tolist()[:6]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Calories (kcal)'].nlargest(5).to_list()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Total Sugar (g)'].sort_values().head(3).values\nans = answer(df)",
    "{\n    \"solution\": \"df[['Total Fat (g)', 'Total Fat (%DV)']].sort_values('Total Fat (%DV)', ascending=False).head(4)['Total Fat (g)'].tolist()\"\n}\n\n\nInput DataFrame columns: ['name', 'Calories (kcal)', 'Carbohydrates (g)', 'Total Sugar (g)', 'Protein (g)', 'Total Fat (g)', 'Saturated Fat (g)', 'Monounsaturated Fat (g)', 'Polyunsaturated Fat (g)', 'Total Fiber (g)', 'Cholesterol (mg)', 'Sodium (g)', 'Potassium (g)', 'Calcium (g)']\nQuestion: Add a new column to the DataFrame called 'fats' that calculates the total amount of fats in grams. \nExpected return type: DataFrame\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['fats'] = df[['Saturated Fat (g)', 'Monounsaturated Fat (g)', 'Polyunsaturated Fat (g)']].sum(axis=1)\"\n}\n\n\nInput DataFrame columns: ['item_id', 'item_name', 'category_id', 'category_name']\nQuestion: How many category names are not 'Wine'?\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['category_name'].value_counts().loc['Wine']\"\n}\n\n\nInput DataFrame columns: ['id', 'name', 'age', 'married', 'children']\nQuestion: What is the max age of the single individuals?\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['married'] == False]['age'].max()\"\n}\n\n\nInput DataFrame columns: ['id', 'name', 'age', 'married', 'children']\nQuestion: What is the average age of the single individuals?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['married'] == False]['age'].mean()\"",
    "{\n    \"solution\": \"df.nsmallest(6, 'Protein (g)')[['Name', 'Protein (g)']].values.tolist()\"\n}\n\n\nInput DataFrame columns: ['Drug', 'A', 'B', 'C', 'D']\nQuestion: Which drug in the dataset is the most similar to 'B'?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.loc[df['B'].idxmax(), 'Drug']\"\n}\n\n\nInput DataFrame columns: ['timestamp', 'username', 'text']\nQuestion: Which user has the most unique words?\nExpected return type: string\n\nCode that calculates the answer:\n{\n    \"solution\": \"df.groupby('username')['text'].apply(lambda x: len(set(x.str.split().sum()))).idxmax()\"\n}\n\n\nInput DataFrame columns: ['date', 'Close', 'Open', 'High', 'Low']\nQuestion: What is the average high price of the day with the highest low price?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['Low'] == df['Low'].max()]['High'].mean()\"\n}\n\n\nInput DataFrame columns: ['Date of Purchase', 'Description', 'High',  'Low', 'Open', 'Volume']\nQuestion: What is the ratio between the average low and high prices on Sundays?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[df['Date of Purchase'].dt.dayofweek == 6]['High'].mean() / df[df['Date of Purchase'].dt.dayofweek == 6]['Low'].mean()\"\n}\n\n\nInput DataFrame columns: ['time', 'duration_s']\nQuestion: What is the average duration of the longest call?\nExpected return type: number\n\nCode that calculates the answer:\n{\n    \"solution\": \"df['duration_s'].max()\"\n}\n\n\n\nInput DataFrame columns: ['city', 'country', 'gender', 'user_id', 'age', 'signup_date',",
    "{\n    \"solution\": \"df.loc[df['edu'] == 'No primary', 'const']\"\n}\n\n\nInput DataFrame columns: ['age', 'sex', 'religion', 'voted', 'edu', 'automation', 'vote', 'politicalInterest', 'maritalStatus', 'race', 'income', 'party', 'province', 'region']\nQuestion: Is the average age of the non-religious male voters lower than the average age of the religious female voters who voted in the 2004 presidential election?\nExpected return type: boolean\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[(df['religion'] == 'No') & (df['voted'] == 'Voted') & (df['sex'] == 'Male')]['age'].mean() < df[(df['religion'] == 'Yes') & (df['voted'] == 'Voted') & (df['sex'] == 'Female')]['age'].mean()\"\n}\n\n\nInput DataFrame columns: ['Sex', 'Age', 'City', 'Political Party', 'Economic party', 'Annealing', 'Austerity', 'Growth', 'War', 'Illiberalism', 'Terrorist', 'Corruption', 'Constitutional', 'Defense', 'Trade', 'Citizenship', 'Immigration', 'Stability', 'Rule of law', 'Democracy', 'Proportional', 'Pragmatism', 'Civil rights', 'Women', 'Nationalism', 'Reforms', 'Corruption', 'EU', 'Illuminism', 'Reconciliation', 'Freedom', 'Libertarianism']\nQuestion: Is there a statistically significant difference between the age of the average male and female Spanish voters?\nExpected return type: boolean\n\nCode that calculates the answer:\n{\n    \"solution\": \"stats.ttest_ind(df.query('Sex == \\'Male\\')['Age'], df.query('Sex == \\'Female\\')['Age']).pvalue < 0.05\"\n}\n\n\n\nInput DataFrame columns: ['personName', 'age', 'finalWorth', 'category',",
    "global ans\n\ndef answer(df):\n    return df.polInterest.value_counts().max() == df.shape[0]\nans = answer(df)",
    "{\n    \"solution\": \"vote_reason.str.contains('vote').any()\"\n}\n\n\nInput DataFrame columns: ['v1', 'v2', 'v3', 'v4', 'v5', 'v6', 'v7', 'v8', 'v9', 'v10', 'v11', 'v12', 'v13', 'v14', 'v15', 'v16', 'v17', 'v18', 'v19', 'v20', 'v21', 'v22', 'v23', 'v24', 'v25', 'v26', 'v27', 'v28', 'v29', 'v30', 'v31', 'v32', 'v33', 'v34', 'v35', 'v36', 'v37', 'v38', 'v39', 'v40', 'v41', 'v42', 'v43', 'v44', 'v45', 'v46', 'v47', 'v48', 'v49', 'v50', 'v51', 'v52', 'v53', 'v54', 'v55', 'v56', 'v57', 'v58', 'v59', 'v61', 'v62', 'v63', 'v64', 'v65', 'v66', 'v67', 'v68', 'v69', 'v70', 'v71', 'v72', 'v73', 'v74', 'v75', 'v76', 'v77', 'v78', 'v79', 'v80', 'v81', 'v82', 'v83', 'v84', 'v85', 'v86', 'v87', 'v88', 'v89', 'v90', 'v92', 'v93', 'v95', 'v96', 'v97', 'v98', 'v9",
    "{\n    \"solution\": \"df['User self-placement on Left-Right economic values axis'].max() > df['User self-placement on Progressive-Conservative economic values axis'].max()\"\n}\n\n\nInput DataFrame columns: ['sex', 'age', 'income', 'race', 'marital-status', 'education', 'affairs']\nQuestion: What is the average age of non-affair male with a bachelor degree?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[(df['affair'] == 0) & (df['sex'] == 'male') & (df['education'] == 'Bachelors')]['age'].mean()\"\n}\n\n\nInput DataFrame columns: ['religious', 'education', 'age', 'occupation', 'race', 'yrs_married', 'children', 'capital_gain', 'capital_loss', 'hr_per_week', 'country']\nQuestion: How many people are as educated as the average age of married women with at least two children?\nExpected return type: int\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[(df['marital-status'] == 'Married-civ-spouse') & (df['children'] >= 2)]['education'].value_counts().idxmax()\"\n}\n\n\nInput DataFrame columns: ['party', 'hand', 'age', 'religion', 'educ', 'employ']\nQuestion: What is the probability of a woman being in the labour force with an age between 25 and 35?\nExpected return type: float\n\nCode that calculates the answer:\n{\n    \"solution\": \"df[(df['employ'] != 'Never-worked') & (df['age'] > 25) & (df['age'] < 35) & (df['party'] == 'Labour')]['party'].count() / df[(df['employ'] != 'Never-worked') & (df['age'] > 25) & (df['age'] < 35)]['party'].count()\"\n}\n\n\nInput DataFrame columns: ['relig', 'water",
    "{\n    \"solution\": \"df.value_counts(subset=['User self- placement on Progressive-Conservative economic values axis']).loc[10].values[0]\"\n}\n\n\nInput DataFrame columns: ['V2', 'V1', 'V18', 'V17', 'V16', 'V15', 'V14', 'V13', 'V12', 'V11', 'V10', 'V9', 'V8', 'V7', 'V6', 'V5', 'V4', 'V3', 'Const', 'edu', 'gender', 'lang', 'partyId', 'polInterest', 'prevVote', 'prevVoteCat', 'prov', 'voteReason', 'Austerity politics are needed in order to overcome the crisis', 'The growth of Islam is a threat to the security of Spain', 'The church must pay the IBI', 'The fact that gay couples can adopt children is positive for society', 'Women should choose freely on issues of abortion', 'The immigration detention centres (CIES) should be closed', 'Schools segregated by sex should also be subsidized by the state', 'Spain must tighten its immigration policy', 'Bullfights in Spain should be banned', \"The 'gag law' is necessary to avoid social unrest\", 'In order to fight organized crime, restrictions on civil rights and liberties must be accepted', 'Efficiency in the delivery of public services will be improved with private sector participation', 'Negotiations with ETA weaken the state', 'The political party that receives the most votes should govern', 'Decentralizati on in Spain is inadequate and should continue to expand', 'Linguistic policy in the autonomous regions discriminates against Spanish language', 'The central government should control the spending of regional governments to limit their indebtedness', 'The possibility of a referendum on self- determination of any Autonomous Community must be recognized by the Constitution', 'The 1978 Constitution is the appropriate framework for our society', 'Navarra and the Basque Country should retain their tax system', 'Catalonia must be",
    "global ans\n\ndef answer(df):\n    return df['Age'].mean()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df[df['voteReason'] == 'It should be more difficult for companies to lay off workers'].shape[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Age'].max()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Vote Intention'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['voteReason'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['partyId'].mode().iloc[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['lang'].value_counts().index[0]\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['Vote Intention'].value_counts().iloc[:5].index.tolist()\nans = answer(df)",
    "{\n    \"solution\": \"df[['Vote Intention', 'Age', 'const', 'edu', 'gender', 'lang', 'partyId', 'polInterest', 'prevVote', 'prevVoteCat', 'prov', 'Austerity politics are needed in order to overcome the crisis', 'The growth of Islam is a threat to the security of Spain', 'The church must pay the IBI', 'The fact that gay couples can adopt children is positive for society', 'Women should choose freely on issues of abortion', 'The immigration detention centres (CIES) should be closed', 'Schools segregated by sex should also be subsidized by the state', 'Spain must tighten its immigration policy', 'Bullfights in Spain should be banned', \"The 'gag law' is necessary to avoid social unrest\", 'In order to fight organized crime, restrictions on civil rights and liberties must be accepted', 'Efficiency in the delivery of public services will be improved with private sector participation', 'Negotiations with ETA weaken the state', 'The political party that receives the most votes should govern', 'Decentralizati on in Spain is inadequate and should continue to expand', 'Linguistic policy in the autonomous regions discriminates against Spanish language', 'The central government should control the spending of regional governments to limit their indebtedness', 'The possibility of a referendum on self- determination of any Autonomous Community must be recognized by the Constitution', 'The 1978 Constitution is the appropriate framework for our society', 'Navarra and the Basque Country should retain their tax system', 'Catalonia must be recognized as a nation', 'The government should take a tougher line against the persecution of opposition leaders in Venezuela', 'The number of public sector workers should be increased', 'The European Union must do more to support the Greek economy', 'It should be more difficult for companies to lay off workers', 'Bailing out banks is needed in order to restore economic stability', 'Increasing university fees is necessary for the sustainability of the university system', 'The government should subsidize clean energy in order to",
    "global ans\n\ndef answer(df):\n    return df['partyId'].value_counts().head(3).index.tolist()\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df['edu'].value_counts().head(3).index\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return list(df['Age'].value_counts(dropna=False).head(3).index)\nans = answer(df)",
    "global ans\n\ndef answer(df):\n    return df.groupby(['voteReason'])['User self-placement on Left-Right economic values axis'].mean().sort_values().iloc[-3:].index.tolist()\nans = answer(df)",
    "{\n    \"solution\": \"df[(df['voteReason'] == 'User self- placement on Progressive-Conservative economic values axis')]['voteIntention'].value_counts()[:4].index.tolist()\"\n}\n\n\nInput DataFrame columns: ['Vote Intention', 'Age', 'const', 'edu', 'gender', 'lang', 'partyId', 'polInterest', 'prevVote', 'prevVoteCat', 'prov', 'Austerity politics are needed in order to overcome the crisis', 'The growth of Islam is a threat to the security of Spain', 'The church must pay the IBI', 'The fact that gay couples can adopt children is positive for society', 'Women should choose freely on issues of abortion', 'The immigration detention centres (CIES) should be closed', 'Schools segregated by sex should also be subsidized by the state', 'Spain must tighten its immigration policy', 'Bullfights in Spain should be banned', \"The 'gag law' is necessary to avoid social unrest\", 'In order to fight organized crime, restrictions on civil rights and liberties must be accepted', 'Efficiency in the delivery of public services will be improved with private sector participation', 'Negotiations with ETA weaken the state', 'The political party that receives the most votes should govern', 'Decentralizati on in Spain is inadequate and should continue to expand', 'Linguistic policy in the autonomous regions discriminates against Spanish language', 'The central government should control the spending of regional governments to limit their indebtedness', 'The possibility of a referendum on self- determination of any Autonomous Community must be recognized by the Constitution', 'The 1978 Constitution is the appropriate framework for our society', 'Navarra and the Basque Country should retain their tax system', 'Catalonia must be recognized as a nation', 'The government should take a tougher line against the persecution of opposition leaders in Venezuela', 'The number of public sector workers should be increased', 'The European Union must do more to support the Greek economy', 'It should be more difficult for companies to lay",
    "global ans\n\ndef answer(df):\n    return df['Constitutional organisation of the country (More Descentralization)'].value_counts().nlargest(2).index.tolist()\nans = answer(df)"
]